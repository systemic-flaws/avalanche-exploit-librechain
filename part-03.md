# Avalanche Protocol Signature Exploit: Part Three

https://librechain.org/avalanche-protocol-signature-exploit-part-three

---

### ecdsa.SignCompact

For some reason, the link referenced here underneath this function points to: 

https://github.com/decred/dcrd/blob/9408498fd00555dd268e4987e5c89cd53ab9051f/dcrec/secp256k1/ecdsa/signature.go#L755-L780

However, that is not where the library is inherited from.

The library used in secp256k1r.go inherits from: 

https://pkg.go.dev/github.com/decred/dcrd/dcrec/secp256k1/v3/ecdsa


<details>
<summary> <h3> Analysis </h3></summary>

The link to github:

https://github.com/decred/dcrd/blob/9408498fd00555dd268e4987e5c89cd53ab9051f/dcrec/secp256k1/ecdsa/signature.go#L755-L780

points to V4 of the decred library.
  
The avalanche code uses the V3 version (this is stated correctly by the author)

https://pkg.go.dev/github.com/decred/dcrd/dcrec/secp256k1/v3/ecdsa  

Going on, the author  strays away (Instead of linking to the github code of the V3 version, for a direct comparison).

Here is the relevant code of the decred V3 library, used in Avalanche:
  
https://github.com/decred/dcrd/blob/86b11abbd6934a94a1e9c09272c6b603fe319354/dcrec/secp256k1/ecdsa/signature.go#L715-L740
  
```go
  func SignCompact(key *secp256k1.PrivateKey, hash []byte, isCompressedKey bool) []byte {
	// Create the signature and associated pubkey recovery code and calculate
	// the compact signature recovery code.
	sig, pubKeyRecoveryCode := signRFC6979(key, hash)
	compactSigRecoveryCode := compactSigMagicOffset + pubKeyRecoveryCode
	if isCompressedKey {
		compactSigRecoveryCode += compactSigCompPubKey
	}


	// Output <compactSigRecoveryCode><32-byte R><32-byte S>.
	var b [compactSigSize]byte
	b[0] = compactSigRecoveryCode
	sig.r.PutBytesUnchecked(b[1:33])
	sig.s.PutBytesUnchecked(b[33:65])
	return b[:]
}
```
  
`signRFC6979` contains the call to `secp256k1.NonceRFC6979`  

https://github.com/decred/dcrd/blob/86b11abbd6934a94a1e9c09272c6b603fe319354/dcrec/secp256k1/ecdsa/signature.go#L593-L595
  
```go
// Generate a deterministic nonce in [1, N-1] parameterized by the
// private key, message being signed, and iteration count.
k := secp256k1.NonceRFC6979(privKeyBytes[:], hash, nil, nil, iteration)
```

### => ecdsa.SignCompact => signRFC6979 => secp256k1.NonceRFC6979
  
### => RFC6979 compliant nonce-generation exists  
    
  
