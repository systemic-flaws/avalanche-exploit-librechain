# Avalanche Protocol Signature Exploit: Part One

<details>
<summary> <h3> Intro </h3></summary>

### Critical 0Day Ignored by Team Allows for Trivial Recovery of Validator Private Keys. Entire Project Should be Considered Compromised

This series includes each report I sent to the Avalanche protocol team detailing a potent zero-day vulnerability in their AvalancheGo implementation that allows for the recovery of private keys from signatures formed by nodes & validators. This vulnerability, which they refuse to patch, allows for the private keys of validators to be forged, which essentially renders the entire protocol compromised. If there's anybody out there that's using Avalanche at the time of writing...my best advice as an objective observer and researcher would be to remove any funds you have on this protocol ASAP.

Everything below includes what I sent to the Avalanche dev team on HackenProof in response to their request for more information about this vulnerability. At the bottom of this initial report is a proof of concept where I successfully recover a private key.

Official Report to Avalanche Developers (Part One)
Pursuant to your request for more information and a reproducible means of exploring this vulnerability/flaw in the design of the signature algorithm, I'm appending this report as an informal "part two" of sorts.

As a recap, I'll start with the information that I wrote about RFC-6979 deterministic signatures using ecdsa.

</details>



<details>
<summary> <h3> Walking Through How to Create a Signature with ECDSA </h3></summary>

In this process, we'll assume that we already have our private key ('x') and public key ('y') [the latter won't be necessary for the formation of the signature].

The other variables as defined for secp256k1 in the secg specification still applies.

calculate the hash of the message (sha256 hash algo for consistency): h = hash(msg)

generate a value for 'k': that falls within the range of [1..n-1]

derive an x,y coordinate from 'k' the same way we did for 'x': R (random point) = $k*G$

take the x-coordinate of 'R': $r = R.x$

calculate the signature proof: $s = k^{-1} (h + r x) (modulo n)$

The above steps yield a signature, which is represented by the variables (r, s), which are:

x value of the pseudo-pubkey coordinate derived from our ephemeral 'private key' (k) = r

signature proof itself = s = ($k^{-1} * (h + (rx)) (modulo n)$)

</details>



<details>
<summary> <h3> !!! Getting to the Root of the Issue on Avalanche </h3></summary>
  
!!! This is documentation code that does not exist within the repository

https://docs.avax.network/subnets/create-a-vm-blobvm

```go
// Create the unsigned transaction for SetTx
utx := &chain.SetTx{
    BaseTx: &chain.BaseTx{},
    Value:  []byte("data"),
}

utx.SetBlockID(lastAcceptedID)
utx.SetMagic(genesis.Magic)
utx.SetPrice(price + blockCost/utx.FeeUnits(genesis))

// Calculate the digest hash for the transaction.
digest, err := chain.DigestHash(utx)

// Sign the digest hash with the issuer's private key.
signature, err := chain.Sign(digest, privateKey)
```

</details>

<details>
<summary> <h3> !!! Actually Recovering Private Keys from Reused Nonces</h3></summary>
  
!!! This is python code, not(!) related to the avalanche go code  
  
  https://asecuritysite.com/encryption/ecd3
  
Demonstrated code uses `ecdsa.NIST256p.generator`, not `G = ecdsa.SECP256k1.generator` (secp256k1 is used by avalanche)

</details>






<details>
<summary> <h3>  </h3></summary>

</details>


