# Avalanche Protocol Signature Exploit: Part One

https://librechain.org/avalanche-protocol-signature-exploit-part-one

---
### Getting to the Root of the Issue on Avalanche

https://docs.avax.network/subnets/create-a-vm-blobvm

```go
// Create the unsigned transaction for SetTx
utx := &chain.SetTx{
    BaseTx: &chain.BaseTx{},
    Value:  []byte("data"),
}

utx.SetBlockID(lastAcceptedID)
utx.SetMagic(genesis.Magic)
utx.SetPrice(price + blockCost/utx.FeeUnits(genesis))

// Calculate the digest hash for the transaction.
digest, err := chain.DigestHash(utx)

// Sign the digest hash with the issuer's private key.
signature, err := chain.Sign(digest, privateKey)
```

#### Validation

* **=> irrelevant:** This is documentation code that does not exist within the avalanche code repository

---
### Actually Recovering Private Keys from Reused Nonces

https://asecuritysite.com/encryption/ecd3

#### Validation

* **=> irrelevant:** Demonstrated code uses `ecdsa.NIST256p.generator`, not `G = ecdsa.SECP256k1.generator` (secp256k1 is used by avalanche)
* **=> irrelevant:** This is python code, not(!) related to the avalanche go code    

