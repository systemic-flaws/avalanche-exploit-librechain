# Avalanche Protocol Signature Exploit: Part Four

Ignore the whole document. Use this code within e.g. Visual Studio Code.

```go
// add this to /utils/crypto/secp256k1r.go to make private (lower-case)
// function available outside of package (upper-case)
func RawSigToSig(sig []byte) ([]byte, error) {
	return rawSigToSig(sig)
}
```

```go
// replace the main, then start it
// Use debugger / single-step to see the avalanche does everything fine
package main

import (
	"encoding/hex"
	"fmt"

	"github.com/ava-labs/avalanchego/utils/crypto"
	"github.com/ava-labs/avalanchego/utils/hashing"

	"github.com/decred/dcrd/dcrec/secp256k1/v3"
	"github.com/decred/dcrd/dcrec/secp256k1/v3/ecdsa"
)

func main() {
	// Hexadecimal private key
	privateKeyHex := "eeac0e3d8f0fcc32a553cc5ab8dad48a435bb4c047d95b06eb7a29a4a823e87c"

	// Parse the private key
	privateKeyBytes, _ := hex.DecodeString(privateKeyHex)

	// Create a new private key object from the parsed bytes
	// factory := &FactorySECP256K1R{}
	factory := &crypto.FactorySECP256K1R{}
	privateKey, err := factory.ToPrivateKey(privateKeyBytes)
	if err != nil {
		panic(err)
	}

	privateKeyDecred := secp256k1.PrivKeyFromBytes(privateKeyBytes)

	// Print the private key source in hex format
	fmt.Printf("Private key bytes: %x\n", privateKeyBytes)

	// Print the private key in hex format
	fmt.Printf("Private key Ava   : %x\n", privateKey.Bytes())
	fmt.Printf("Private key Decred: %x\n", privateKeyDecred.Serialize())

	// Derive the public key from the private key
	publicKey := privateKey.PublicKey()
	publicKeyDecred := privateKeyDecred.PubKey()

	// Print the public key in hex format
	fmt.Printf("Public key Ava    : %x\n", publicKey.Bytes())
	fmt.Printf("Public key Decred : %x\n", publicKeyDecred.SerializeCompressed())

	// Sign a message using the private key
	message := []byte("avalanchesignature")
	signature, err := privateKey.Sign(message)
	if err != nil {
		panic(err)
	}

	fmt.Printf("Signature Ava    : %x\n", signature)

	// here we use decred v3 ecdsa.SignCompact directly

	// hash first, as in avalanche
	hashedMessage := hashing.ComputeHash256(message)

	// SignCompact, as in avalanche, but with a direct call to the decred code
	signatureDecredRaw := ecdsa.SignCompact(privateKeyDecred, hashedMessage, false)

	fmt.Printf("Signature DecredR: %x\n", signatureDecredRaw)

	// apply the RawSigToSig conversion avalanche does to be able to compare
	signatureDecred, _ := crypto.RawSigToSig(signatureDecredRaw)

	fmt.Printf("Signature Decred : %x\n", signatureDecred)

	// Again the Avalanche signature for comparison
	fmt.Printf("Signature Ava    : %x\n", signature)

}

```
